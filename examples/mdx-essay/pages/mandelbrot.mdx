import { Layout } from "../components/layout";
import { Complex2D, ComplexNumber } from "../components/complex";
import { Iterate2D } from "../components/iterations";
import { Mandelbrot } from "../components/mandelbrot";
import { createState, Observe, Input } from "mdx-state";
import { InlineMath, BlockMath } from "react-katex";
import "katex/dist/katex.min.css";

export default Layout;

# Explaining the Mandelbrot Set, visually

The Mandelbrot Set is noe of the most interesting objects of Computer Graphics.
So let's try to get a visual understanding of the process that is used to arrive at these intricate visuals.

The Mandelbrot Set is defined as the set of complex numbers <InlineMath math="c" /> for which the following sequence, starting at 0, does not diverge: 

<div>
<BlockMath math={`z_{n+1}=z_{n}^{2}+c`} />
</div>

So what does that actually mean? It means that we have an _iterative_ process. We start with an initial value, plug it in to the <InlineMath math="z_{n}" /> part of the equation and calculate the result. We then put the result back into the equation to calculate the next iteration, and so on.

Let's get a feeling for how our equation behaves for different starting values <InlineMath math="c" />. Complex numbers take the following form:

<div>
<BlockMath math="a+ib" />
</div>

where <InlineMath math="a" /> is called the *real part*, and <InlineMath math="b" /> the *imaginary part*. Since complex numbers basically have two components, this means that we can visualise them nicely in a 2D plot. By convention, the real part is the x-axis and the imaginary part the y-axis.

export const example1 = createState({ x: 0.2, y: 0.3 });

<Observe state={example1}>
{state => <div className="flex gap-10">
	<Complex2D
		{...state}
		onChange={({ x, y }) => {
			example1.x = x;
			example1.y = y;
		}}
	/>

	<div className="text-base flex items-center">
	<p>Here you can see the complex number <ComplexNumber re={state.x} im={state.y} /> on a 2D plane. Drag the point on the left to see the value change!</p>
	</div>
</div>}
</Observe>

export const example2 = createState({ x: 0.2, y: 0.3, iterations: 15 });

Let's see how this behaves when we iterate the point. Here is a chart that shows the path that a complex number takes as it is iterated. Go ahead and play around with it! Get a feeling for how our iterating function behaves.

<Observe state={example2}>
{state => <div className="flex gap-10">
	<Iterate2D {...state}
			onChange={({ x, y }) => {
				example2.x = x;
				example2.y = y;
			}}
	 />
	
	<div className="text-base flex items-center">
	<p>Here you can see the path that <ComplexNumber re={state.x} im={state.y} /> takes after <Input className="w-14 border border-gray-500 rounded-sm pl-2" type="number" min="0" max="200" state={example2} name="iterations" /> iterations.
	Adjust the number to iterations to see how the pattern continues!
	</p>
	</div>
</div>}
</Observe>

As you play around with the value, you will notice that some of the values seem to get closer and closer to a certain point, forming beautiful spirals along the way <button className="underline" onClick={() => {
	example2.x = 0.35;
	example2.y = -0.32;
	example2.iterations = 100;
}}>(this one for an example)</button>.
Other values seem to shoot off into infinity after a while.

<Observe state={example2}>
{state => <div className="grid">
<Mandelbrot iterations={example2.iterations} className="col-span-full row-span-full" />
<Iterate2D {...state} lineColor="#999" lineWidth={2} className="col-span-full row-span-full"
		onChange={({ x, y }) => {
			example2.x = x;
			example2.y = y;
		}}
 />
 </div>}
 </Observe>